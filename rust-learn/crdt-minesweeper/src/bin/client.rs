use std::{time::Duration, net::{Ipv6Addr, IpAddr}};

use automerge::sync::{Message, SyncDoc};
use autosurgeon::reconcile;

use crdt_minesweeper::{RpcClient, MineField, Grid, FIELD_SIZE};
use tarpc::{
    client, context, tokio_serde::formats::Bincode,
};
use tokio::time::sleep;

#[derive(Debug)]
struct Error;

impl std::error::Error for Error {}

impl std::fmt::Display for Error {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "")
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), 6009);
    let mut transport = tarpc::serde_transport::tcp::connect(&server_addr, Bincode::default);
    transport.config_mut().max_frame_length(usize::MAX);

    // WorldClient is generated by the #[tarpc::service] attribute. It has a constructor `new`
    // that takes a config and any Transport as input.
    let mut client = RpcClient::new(client::Config::default(), transport.await?).spawn();

    // Basic example below
    let hello = async move {
        tokio::select! {
            Ok(uuid) = client.connect(context::current(), ()) => {
                println!("On client {}", uuid);
                uuid
            }
        }
    }.await;
    println!("awaited result: {hello:?}");

    // Let the background span processor finish.
    sleep(Duration::from_micros(1)).await;

    let mut peer1 = automerge::AutoCommit::new();
    let mut peer1_state = automerge::sync::State::new();
    // Peer 1 puts data into the document
    reconcile(
        &mut peer1,
        &MineField {
            grid: Grid::new(FIELD_SIZE),
        },
    )
    .unwrap();
    let message1to2 = peer1
        .sync()
        .generate_sync_message(&mut peer1_state)
        .ok_or(Error {})
        .unwrap()
        .encode();

    loop {
        let res = client.sync(context::current(), message1to2).await?;
        let two_to_one = Message::decode(&res);
        if let Ok(message) = &two_to_one {
            println!("two to one");
            peer1
                .sync()
                .receive_sync_message(&mut peer1_state, message.to_owned())
                .unwrap();
        }
        let one_to_two = peer1.sync().generate_sync_message(&mut peer1_state);
        if let Some(message) = &one_to_two {
            println!("one to two");
            client.sync(context::current(), message.to_owned().encode()).await?;
        }
        if (&two_to_one).is_err() && one_to_two.is_none() {
            break;
        }
    }

    Ok(())
}
