#+TITLE: Chapter 1

* 1.1.8 Procedures as Black-Box Abstractions

Mention of recursive functions! Finally! The procedure is determined in terms of
itself.

To build a program we want to *decompose* a problem in subproblems, but this
decomposition has to be meaningful.  We want to create *Procedural Abstractions*.

Create sub-procedures so their implementation —the details– is
indistinguishable, only the behavior is what we want to care about.

Parameters –at least in scheme— have a local name, to avoid conflicts with
external variables.  Procedures are said to have *formal parameters*, the
definition of the procedure *binds* its parameters, no matter what their name
is.  If a variable is not *bound* it is *free* (in other words, a free variable
is neither a parameter nor a local variable in the procedure).

** Internal definitions

Sub-procedures can be defined inside another procedure, to avoid name conflicts.
=sqrt= can be rewritten like this:

#+begin_src scheme
(define (square x) (* x x))

(define (average x y)
  (/ (+ x y) 2))

(define (sqrt x)
  (define (good-enough? guess)
    (< (abs (- (square guess) x)) 0.001))
  (define (improve guess)
    (average guess (/ x guess)))
  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))
  (sqrt-iter 1.0))

(sqrt 4)
#+end_src

#+RESULTS:
: 2.0000000929222947

This makes =sqrt= a blackbox, users do not have to know or care about =improve=
or =good-enough?= to use it effectively.
* 1.2 Procedures and the Processes They Generate
** 1.2.1 Linear Recursion and Iteration
Typical approach for defining factorial:

#+begin_src scheme
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

(factorial 3)
#+end_src

#+RESULTS:
: 6

Other approach: we use a counter and accumulate a product.

#+begin_src scheme
(define (factorial n)
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                   (+ counter 1)
                   max-count)))
  (fact-iter 1 1 n))

(factorial 6)
#+end_src

#+RESULTS:
: 720

The first definition requires the interpreter to keep the track of the operation
for each level in the computation, it is a *linear recursive process* growing
linearly on n, whereas the second one does not grow but has =n= steps, it is a
*linear iterative process*.

Note: We are talking here about processes *not* procedures.
**** Exercise 1.9
First one:
#+begin_src scheme
(+ 4 5)
(inc (+ (dec 4) 5))
(inc (+ 3 5))
(inc (inc (+ (dec 3) 5)))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ (dec 2) 5))))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ (dec 1) 5)))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
#+end_src

Second one:
#+begin_src scheme
(+ 4 5)
(+ (dec 4) (inc 5))
(+ 3 6)
(+ (dec 3) (inc 6))
(+ 2 7)
(+ (dec 2) (inc 7))
(+ 1 8)
(+ (dec 1) (inc 8))
(+ 0 9)
9
#+end_src

**** Exercise 1.10
Ackermann's function:

#+name: ackermann
#+begin_src scheme
(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
#+end_src

#+begin_src scheme :noweb yes
<<ackermann>>
(list (A 1 10)
      (A 2 4)
      (A 3 3))
#+end_src

#+RESULTS:
: (1024 65536 65536)

Simplify:
#+begin_src scheme
(define (f n) (A 0 n))
;; since x is 0 we can substitute?
(define (f n) (* 2 n))

(define (g n) (A 1 n))
(A (- 1 1)
   (A 1 (- n 1)))
(A 0 (A 1 (- n 1)))
(* 2 (A 1 (- n 1)))
(* 2 (A 0
        (A 1 (- n 1))))

;; g is (2n)ⁿ ?

#+end_src
** 1.2.2 Tree Recursion
*** Counting change
Rewritten in a clearer way?
#+begin_src scheme
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond [(= amount 0) 1]
        [(or (< amount 0)
             (= kinds-of-coins 0))
         0]
        [else
         (let* ([next-coin (- kinds-of-coins 1)]
                [coin-value (first-denomination kinds-of-coins)]
                [rest (- amount coin-value)])
           (+ (cc amount next-coin)
              (cc rest kinds-of-coins)))]))

(define (first-denomination kinds-of-coins)
  (case kinds-of-coins [(1) 1]
                       [(2) 5]
                       [(3) 10]
                       [(4) 25]
                       [(5) 50]))
#+end_src

** 1.2.3 Orders of growth
Amount of resources to solve a problem: =R(n)=
With =n= the parameter that measures the size of the problem.

Somewhat similar to the big O notation? =O(n)=

=R(n)= has order of growth =Θ(f(n))=  (Θ is /theta/)

 e.g.:
 - The *recursive* factorial process grows as =Θ(n)=, the space required grows
   as =Θ(n)=.
 - The *iterative* factorial process also grows as =Θ(n)= but the space is
   =Θ(1)= — constant.
 - The *tree-recursive* Fibonacci computation requires =Θ(φn)= steps and space
   =Θ(n)=

(note: φ is the golden ratio φ = 1+√5/2 ≈ 1.6180)
*** COMMENT Exercise 1.14
#+begin_quote
Draw the tree illustrating the process generated by the count-change procedure
of 1.2.2 in making change for 11 cents. What are the orders of growth of the
space and number of steps used by this process as the amount to be changed
increases?
#+end_quote

#+begin_src scheme :results output
(define (count-change amount)
  (define (cc amount kinds-of-coins)
    (cond ((= amount 0) 1)
          ((or (< amount 0)
               (= kinds-of-coins 0))
           0)
          (else
           (pretty-print `(+ (cc ,amount ,(- kinds-of-coins 1))
                             (cc ,(- amount (first-denomination
                                             kinds-of-coins)) ,kinds-of-coins)))
           (+ (cc amount (- kinds-of-coins 1))
              (cc (- amount (first-denomination
                             kinds-of-coins))
                  kinds-of-coins)))))
  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))

  (cc amount 5))
#+end_src

#+RESULTS:
: (+ (cc 11 4) (cc -39 5))
: (+ (cc 11 3) (cc -14 4))
: (+ (cc 11 2) (cc 1 3))
: (+ (cc 11 1) (cc 6 2))
: (+ (cc 11 0) (cc 10 1))
: (+ (cc 10 0) (cc 9 1))
: (+ (cc 9 0) (cc 8 1))
: (+ (cc 8 0) (cc 7 1))
: (+ (cc 7 0) (cc 6 1))
: (+ (cc 6 0) (cc 5 1))
: (+ (cc 5 0) (cc 4 1))
: (+ (cc 4 0) (cc 3 1))
: (+ (cc 3 0) (cc 2 1))
: (+ (cc 2 0) (cc 1 1))
: (+ (cc 1 0) (cc 0 1))
: (+ (cc 6 1) (cc 1 2))
: (+ (cc 6 0) (cc 5 1))
: (+ (cc 5 0) (cc 4 1))
: (+ (cc 4 0) (cc 3 1))
: (+ (cc 3 0) (cc 2 1))
: (+ (cc 2 0) (cc 1 1))
: (+ (cc 1 0) (cc 0 1))
: (+ (cc 1 1) (cc -4 2))
: (+ (cc 1 0) (cc 0 1))
: (+ (cc 1 2) (cc -9 3))
: (+ (cc 1 1) (cc -4 2))
: (+ (cc 1 0) (cc 0 1))
: 4

We see that there is a additional step and level of depth on the second branch,
for each substraction of the current coin to the amount. Then we repeat this
procedure for each coin. So another step and depth level.

For an amount of money =n= =count-change= has a number of steps of: per type of
coin so =5n=, then substracting until we get to 0 so =n= ~> =Θ(5n×n)= ?

*** Exercise 1.15
#+begin_quote
1. How many times is the procedure p applied when ~(sine 12.15)~ is evaluated?
2. What is the order of growth in space and number of steps (as a function of
   =a=) used by the process generated by the sine procedure when ~(sine a)~ is
   evaluated?
#+end_quote

#+name Sin of 12.15
#+begin_src scheme :results output
(define (cube x) (* x x x))
(define (p x) (- (* 3 x) (* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (begin (pretty-print `(p (sine ,(/ angle 3.0))))
             (p (sine (/ angle 3.0))))))
(sine 12.15)
#+end_src
#+RESULTS:
: (p (sine 4.05))
: (p (sine 1.3499999999999999))
: (p (sine 0.44999999999999996))
: (p (sine 0.15))
: (p (sine 0.049999999999999996))
: -0.39980345741334

1. It is called 5 times
2. Could it be =Θ(n/3)= since we divide by 3 for each recusion step?

